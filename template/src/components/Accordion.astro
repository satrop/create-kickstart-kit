---
export interface AccordionItem {
  id: string;
  title: string;
  content?: string; // Optional plain text content
  htmlContent?: string; // Optional HTML content instead of plain text
}

export interface Props {
  items: AccordionItem[];
  allowMultiple?: boolean;
  variant?: "default" | "bordered" | "flush";
}

const { items, allowMultiple = false, variant = "default" } = Astro.props;
---

<div class={`accordion accordion--${variant}`} data-allow-multiple={allowMultiple}>
  {
    items.map((item, index) => (
      <div class="accordion__item" data-accordion-item>
        <h3 class="accordion__header">
          <button
            class="accordion__trigger"
            type="button"
            aria-expanded="false"
            aria-controls={`accordion-content-${item.id}`}
            id={`accordion-trigger-${item.id}`}
            data-accordion-trigger>
            <span class="accordion__title">{item.title}</span>
            <span class="accordion__icon" aria-hidden="true">
              <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                <path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z" />
              </svg>
            </span>
          </button>
        </h3>

        <div
          class="accordion__content"
          id={`accordion-content-${item.id}`}
          aria-labelledby={`accordion-trigger-${item.id}`}
          role="region"
          data-accordion-content>
          <div class="accordion__body">
            {item.htmlContent ? <div set:html={item.htmlContent} /> : item.content ? <p>{item.content}</p> : null}
          </div>
        </div>
      </div>
    ))
  }
</div>

<style>
  .accordion {
    border-radius: 4px;
    overflow: hidden;
  }

  .accordion--default {
    border: 1px solid #e0e0e0;
  }

  .accordion--bordered .accordion__item {
    border: 1px solid #e0e0e0;
    margin-bottom: 0.5rem;
    border-radius: 4px;
    overflow: hidden;

    &:last-child {
      margin-bottom: 0;
    }
  }

  .accordion--flush {
    border: none;
  }

  .accordion__item {
    /* Base item styles */
  }

  .accordion--default .accordion__item:not(:last-child) {
    border-bottom: 1px solid #e0e0e0;
  }

  .accordion--flush .accordion__item:not(:last-child) {
    border-bottom: 1px solid #e0e0e0;
  }

  .accordion__header {
    margin: 0;
  }

  .accordion__trigger {
    width: 100%;
    padding: 1rem;
    background: transparent;
    border: none;
    text-align: left;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: space-between;
    font-size: 1rem;
    font-weight: 500;
    color: #333;
    transition: all 0.2s ease;

    &:hover {
      background-color: #f8f9fa;
    }

    &:focus {
      outline: 2px solid #007bff;
      outline-offset: -2px;
      background-color: #f8f9fa;
    }

    &[aria-expanded="true"] {
      background-color: #f8f9fa;

      .accordion__icon {
        transform: rotate(45deg);
      }
    }
  }

  .accordion__title {
    flex: 1;
  }

  .accordion__icon {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 1.5rem;
    height: 1.5rem;
    transition: transform 0.2s ease;
    color: #666;
  }

  .accordion__content {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.3s ease;

    &[data-expanded="true"] {
      max-height: 1000px; /* Adjust based on your content needs */
    }
  }

  .accordion__body {
    padding: 0 1rem 1rem 1rem;
    color: #666;
    line-height: 1.6;

    p {
      margin: 0;

      &:not(:last-child) {
        margin-bottom: 1rem;
      }
    }
  }

  /* High contrast mode support */
  @media (prefers-contrast: high) {
    .accordion__trigger:focus {
      outline: 3px solid;
    }
  }

  /* Reduced motion support */
  @media (prefers-reduced-motion: reduce) {
    .accordion__trigger,
    .accordion__icon,
    .accordion__content {
      transition: none;
    }
  }
</style>

<script>
  class AccordionManager {
    private accordion: HTMLElement;
    private allowMultiple: boolean;
    private triggers: NodeListOf<HTMLButtonElement>;
    private contents: NodeListOf<HTMLElement>;

    constructor(accordion: HTMLElement) {
      this.accordion = accordion;
      this.allowMultiple = accordion.dataset.allowMultiple === "true";
      this.triggers = accordion.querySelectorAll("[data-accordion-trigger]");
      this.contents = accordion.querySelectorAll("[data-accordion-content]");

      this.init();
    }

    private init() {
      this.triggers.forEach((trigger, index) => {
        trigger.addEventListener("click", () => this.handleClick(index));
        trigger.addEventListener("keydown", (e) => this.handleKeydown(e, index));
      });
    }

    private handleClick(index: number) {
      const trigger = this.triggers[index];
      const content = this.contents[index];
      const isExpanded = trigger.getAttribute("aria-expanded") === "true";

      if (!this.allowMultiple) {
        // Close all other items
        this.triggers.forEach((otherTrigger, otherIndex) => {
          if (otherIndex !== index) {
            this.collapseItem(otherTrigger, this.contents[otherIndex]);
          }
        });
      }

      if (isExpanded) {
        this.collapseItem(trigger, content);
      } else {
        this.expandItem(trigger, content);
      }
    }

    private handleKeydown(event: KeyboardEvent, index: number) {
      const { key } = event;

      switch (key) {
        case "ArrowDown":
          event.preventDefault();
          this.focusNextTrigger(index);
          break;
        case "ArrowUp":
          event.preventDefault();
          this.focusPreviousTrigger(index);
          break;
        case "Home":
          event.preventDefault();
          this.triggers[0].focus();
          break;
        case "End":
          event.preventDefault();
          this.triggers[this.triggers.length - 1].focus();
          break;
      }
    }

    private expandItem(trigger: HTMLButtonElement, content: HTMLElement) {
      trigger.setAttribute("aria-expanded", "true");
      content.setAttribute("data-expanded", "true");

      // Set max-height to actual height for smooth animation
      const scrollHeight = content.scrollHeight;
      content.style.maxHeight = `${scrollHeight}px`;
    }

    private collapseItem(trigger: HTMLButtonElement, content: HTMLElement) {
      trigger.setAttribute("aria-expanded", "false");
      content.setAttribute("data-expanded", "false");
      content.style.maxHeight = "0";
    }

    private focusNextTrigger(currentIndex: number) {
      const nextIndex = currentIndex === this.triggers.length - 1 ? 0 : currentIndex + 1;
      this.triggers[nextIndex].focus();
    }

    private focusPreviousTrigger(currentIndex: number) {
      const previousIndex = currentIndex === 0 ? this.triggers.length - 1 : currentIndex - 1;
      this.triggers[previousIndex].focus();
    }
  }

  // Initialize all accordions on the page
  document.addEventListener("DOMContentLoaded", () => {
    document.querySelectorAll(".accordion").forEach((accordion) => {
      new AccordionManager(accordion as HTMLElement);
    });
  });
</script>
